% !TEX program = xelatex

\documentclass[a4paper,11pt]{article}
\usepackage{xeCJK}

\usepackage{clrscode}

\usepackage{geometry}
\geometry{
 a4paper,
 left=30mm,
 top=30mm,
}
\usepackage[utf8]{inputenc}

\usepackage{graphicx}
\usepackage[english]{babel}
\usepackage{color}
\usepackage[dvipsnames]{xcolor}
\usepackage[colorlinks=true,urlcolor=blue,citecolor=black]{hyperref}
\usepackage{url}
%\urlstyle{same}
%\urlstyle{rm}
\urlstyle{sf}
%\urlstyle{tt}
\usepackage[font=footnotesize,labelfont=bf]{caption}
\usepackage[labelfont=it,textfont={it},singlelinecheck=on,justification=centering]{caption}
%full name for appendix
\usepackage[title]{appendix}
\usepackage{float}
\setlength{\parindent}{2em}
\usepackage{parskip}
%for code
\usepackage{listings}
%for math
\usepackage{amsmath}
\usepackage{breqn}
\usepackage{pdfpages}
\linespread{1.1}
\setlength{\emergencystretch}{3em}

\usepackage{ifxetex,ifluatex}
\usepackage{etoolbox}
\usepackage{tikz}

\usepackage{framed}

%water mark
\usepackage{eso-pic}

\newcommand{\watermark}[3]{\AddToShipoutPictureBG{
	\parbox[b][\paperheight]{\paperwidth}{
		\vfill%
		\centering%
	\tikz[remember picture, overlay]%
	  \node [rotate = #1, scale = #2] at (current page.center)%
	      {\textcolor{gray!80!cyan!30}{#3}};
	  \vfill}}}
\usepackage{blindtext}
%water mark end


% conditional for xetex or luatex
\newif\ifxetexorluatex
\ifxetex
  \xetexorluatextrue
\else
  \ifluatex
    \xetexorluatextrue
  \else
    \xetexorluatexfalse
  \fi
\fi
%
\ifxetexorluatex%
  \usepackage{fontspec}
  \usepackage{libertine} % or use \setmainfont to choose any font on your system
  \newfontfamily\quotefont[Ligatures=TeX]{STSong} % selects Libertine as the quote font
\else
  \usepackage[utf8]{inputenc}
  \usepackage[T1]{fontenc}
  \usepackage{libertine} % or any other font package
  \newcommand*\quotefont{\fontfamily{LinuxLibertineT-LF}} % selects Libertine as the quote font
\fi

\newcommand*\quotesize{60} % if quote size changes, need a way to make shifts relative
% Make commands for the quotes
\newcommand*{\openquote}
   {\tikz[remember picture,overlay,xshift=-4ex,yshift=-2.5ex]
   \node (OQ) {\quotefont\fontsize{\quotesize}{\quotesize}\selectfont``};\kern0pt}

\newcommand*{\closequote}[1]
  {\tikz[remember picture,overlay,xshift=4ex,yshift={#1}]
   \node (CQ) {\quotefont\fontsize{\quotesize}{\quotesize}\selectfont''};}

% select a colour for the shading
\definecolor{mygray}{gray}{0.95}
\colorlet{shadecolor}{mygray}

\newcommand*\shadedauthorformat{\emph} % define format for the author argument

% Now a command to allow left, right and centre alignment of the author
\newcommand*\authoralign[1]{%
  \if#1l
    \def\authorfill{}\def\quotefill{\hfill}
  \else
    \if#1r
      \def\authorfill{\hfill}\def\quotefill{}
    \else
      \if#1c
        \gdef\authorfill{\hfill}\def\quotefill{\hfill}
      \else\typeout{Invalid option}
      \fi
    \fi
  \fi}
% wrap everything in its own environment which takes one argument (author) and one optional argument
% specifying the alignment [l, r or c]
%
\newenvironment{shadequote}[2][l]%
{\authoralign{#1}
\ifblank{#2}
   {\def\shadequoteauthor{}\def\yshift{-2ex}\def\quotefill{\hfill}}
   {\def\shadequoteauthor{\par\authorfill\shadedauthorformat{#2}}\def\yshift{2ex}}
\begin{snugshade}\begin{quote}\openquote}
{\shadequoteauthor\quotefill\closequote{\yshift}\end{quote}\end{snugshade}}


\usepackage{listings}
\lstdefinestyle{myListStyle}{
  numbers=left,
  stepnumber=1,
  numbersep=10pt,
  tabsize=2,
  showspaces=false,
  showstringspaces=false
}

\usepackage[dvipsnames]{xcolor}
\usepackage{listings}

\newcommand\YAMLcolonstyle{\color{darkgray}\mdseries}
\newcommand\YAMLkeystyle{\color{black}\bfseries}
\newcommand\YAMLvaluestyle{\color{gray}\mdseries}

\makeatletter

% here is a macro expanding to the name of the language
% (handy if you decide to change it further down the road)
\newcommand\language@yaml{yaml}

\expandafter\expandafter\expandafter\lstdefinelanguage
\expandafter{\language@yaml}
{
  keywords={true,false,null,y,n},
  keywordstyle=\color{darkgray}\bfseries,
  basicstyle=\YAMLkeystyle,                                 % assuming a key comes first
  sensitive=false,
  comment=[l]{\#},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{black}\ttfamily,
  stringstyle=\YAMLvaluestyle\ttfamily,
  moredelim=[l][\color{orange}]{\&},
  moredelim=[l][\color{magenta}]{*},
  moredelim=**[il][\YAMLcolonstyle{:}\YAMLvaluestyle]{:},   % switch to value style at :
  morestring=[b]',
  morestring=[b]",
  literate =    {---}{{\ProcessThreeDashes}}3
                {>}{{\textcolor{red}\textgreater}}1
                {|}{{\textcolor{red}\textbar}}1
                {\ -\ }{{\mdseries\ -\ }}3,
}

% switch to key style at EOL
\lst@AddToHook{EveryLine}{\ifx\lst@language\language@yaml\YAMLkeystyle\fi}
\makeatother

\newcommand\ProcessThreeDashes{\llap{\color{cyan}\mdseries-{-}-}}



%opening
\title{\LARGE Qitmeer 白皮书\\
	\Large 信任守护者}
\author{
	Qitmeer 团队\\
		\small\href{mailto:paper@qitmeer.io}
			{\nolinkurl{paper@qitmeer.io}}
	}
\date{\today\\\small Version 0.6.1}
\begin{document}

%% Cover end
\clearpage
\pagestyle{plain}

\maketitle

%\watermark{60}{10}{qitmeer.io}

\begin{abstract}
比特币\cite{bitcoin}与生俱来就带着革命的血液, 开创了以加密学为基础的更开放、更公平去中心化的新一代支付网络. 区块链作为比特币底层账本技术, 因其防篡改的特性, 能够在金融领域发挥关键的作用. 区块链将重塑普惠和伦理金融, 成为全球金融系统里面至关重要的一部分.

比特币诞生的十年以来, 区块链的基础设施正面临许多技术上的挑战. Qitmeer 坚持将开放性, 公平性, 容错性, 可伸缩性作为优质区块链的核心指标, 我们认为满足以上指标为经典区块链设定.

BlockDAG (区块图) 是一种高吞吐的框架, 以完全去中心化以及高安全性闻名. Qitmeer共识采用最先支持交易全排序的 BlockDAG 协议GhostDAG作为基础协议, 同时集成了SPECTRE保证交易的快速确认. Qitmeer 共识遵循经典区块链设定: 节点通过工作量证明可以自由进入和退出网络, 基于DAG账本的合作模型矿工可以根据自己的贡献公平地获得相应的回报, 于比特币相当的50\%算力安全性, 只受网络物理特性限制的强健的可伸缩性. 作为共识算法之外的重要公平性来源, Qitmeer 采用的布谷鸟环是一种基于图理论的工作量证明的挖矿算法因强内存依赖能有效地抗ASIC. 

出于合规的考虑, Qitmeer 设计了基于UTXO的独特的发币极致, 可以有效地应对两大挑战: 固有价值以及资产认证. 发布一定量的资产必须消耗等量的本币, 此外, 发布方必须被授予牌照.

Qitmeer 设计一系列规范与协议以融入全球普惠和伦理金融生态, 例如钱包以及矿工. Qitmeer 利用跨链协议以集成多种加密货币并提供可靠的智能合约服务.

\end{abstract}

\section{介绍}

\subsection{背景}

信任是金融系统的基石, 在传统途径中, 多个互不熟知的个体需要一个可信的第三方来保证交易的安全. 然和, 这个第三方是中心化的, 存在单点故障风险, 很难保证他的诚实.


比特币是一个开放的点对点网络, 意味着不存在一个中心化的服务器, 每个节点可以自由地加入或者退出网络. 计算复杂, 验证简单的工作量证明共识被设计成保证节点能获得与其贡献相应的回报, 本应是一种公平的机制. 比特币采用类似散列表结构的账本以保证防篡改, 这种颠覆式的设计驱动着大量对于其机制的研究. “区块链”的概念就是后被引入来表示这种机制并被广泛接受. 由于免信任以及防篡改的特性, 越来越多的区块链应用涌现在金融领域并成为驱动金融系统重塑的全新动力.

比特币的十年前的创新以来, 区块链的基础设施一直面临着众多技术上的挑战并偏离其哲学的本质. 比特币不再去中心化, 前五大矿池已经控制了大多数的算力使得他们在有必要的情况下可以轻松地攻击网络. 矿工必须加入矿池因为在同等收益期望的情况下可以降低风险. 换言之, 比特币不在公平了. 此外, 比特币不可伸缩, 7笔每秒的吞吐量, 一小时的确认时间, 高昂的交易费, 作为全球支付网络来说很难说是一个令人满意.

比特币需要革新以反映其哲学的本质. 无数种方案声称已经解决了这些挑战. 然而真正做到的并不多, 一般都是牺牲某一种特性而换取另一种特性, 如牺牲去中心化, 安全性的核心来源来换取可伸缩性. 因此, 比特币的哲学本质是什么? Qitmeer 定义其为经典区块链设定, 并深刻启发着Qitmeer网络的设计哲学. 


\subsection{经典区块链设定}
有许多区块链的变种, 各自有各自对区块链的定义.  Qitmeer 网络认可比特币的, 认为如下四种指标为经典区块链设定.

\subsubsection{开放性}
开放性是区分许可链和非许可链的本质特性, 意味着每个节点应该能自由地加入和退出网络.

一个开放的网络应该允许不同的角色, 在比特币网络中, 节点可以自由选择成为SPV (简化支付验证) 节点, 全节点或者矿工, 所以从协议的角度来讲比特币是开放的. 而其他某些共识, 例如, 在代理权益证明中, 区块生产者是根据预定的配置, e.g., 21 个生产者, 在链外被选举产生, 因而限制了网络的开放性.

\subsubsection{公平性}
公平性意味着在一个激励相融的系统中, 回报应该和贡献匹配

\subsubsection*{挖矿风险}
从概率的角度而言, 独立挖矿与加入矿池挖矿的期望收益是相同的, 但是独立挖矿的风险是相当高的, 即要么获得巨额的奖励要么就是长时间得不到任何回报. 因此, 矿工不得不加入矿池以获得稳定的激励. 

\subsubsection*{挖矿效率}
挖矿成本主要包含电力价格以及挖矿效率, 而后者因为ASIC矿机更加关键. ASIC 被定制用于执行特定挖矿算法, 所以单位成本挖矿效率要远高于通用计算机. 例如, 蚂蚁矿机S9 的效率要高出GTX570 两万倍; 个人计算想要参与挖矿竞赛几乎是不可能的. 

\subsubsection{安全性}
安全性是指网络在遭受攻击时的健壮程度. 一般是指推翻一笔确认了的交易


\subsubsection*{去中心化}
去中心化相对于传统支付网络来说是最关键的特性. 去中心化可以规避单点故障, 因为要串通一个去中心化网络中的大部分节点几乎是不可能的.

\subsubsection*{容错性}
容错指网络应该可以承受失效节点的最大比例. 在去中心化网络中, 根据少数服从多数的原则, 50\%的算力容错性是最理想的比例.

\subsubsection{可伸缩性}
随着规模的增长, 网络如果仍能够提供相对稳定增长的服务则可以被认为是可伸缩的. 这些服务包括:
\subsubsection*{吞吐量}
吞吐量是指每秒的交易数, 当网络在扩张时其性能至关重要. 而迄今为止, 比特币当吞吐量仍然限定在七笔每秒, 无论网络有多少节点. 因而限制其成为全球支付网络.

\subsubsection*{确认时间}

确认时间是指接收方需要等待交易不容易被推翻所需的时间, 该时间不应该随着网络规模的增大而增加.  在比特币网络, 确认时间长达六个区块或者一个小时. 确认时间非常影响支付的体验, 例如, 比特币的确认时间是六个区块或一个小时, 一般用户很难接受.

\subsubsection*{成本}

交易费是成本的主要部分, 应该要维持在一个相对合理的范围, 因为如果交易费过高, 支付就不再实用, 而如果过低则容易遭受女巫攻击. 比特币的交易费变得越来越高, 已经不再适合作为原本想成为的全球支付网络. 至目前为止, 比特币的平均交易费大概有两美元之多.

\subsection{设计规范}
Qitmeer 的设计规范遵循经典区块链设定. 这四个指标彼此之间存在内在的矛盾, Qitmeer 不可能同时让每个指标都达到最优, 而是找到一个最佳都平衡, 即在满足公平性和安全性都情况下, 尽可能高地提高可伸缩性.

\subsubsection{开放性}

\subsubsection*{工作量证明}
工作量证明是最开放的加入区块链网络的途径, 因为只需要电力就可以加入, 而电力是一人人都拥有的物理资源. 
\subsubsection*{无预定节点}
预定节点是指协议定义的特殊节点. 注意, 尽管存在矿池这样特殊的节点, 但是它们属于协议之外的产物. 因而, 比特币也是无预定节点的, Qitmeer 在这方面是遵循比特币的规范的, 所以也不存在预定的特殊节点.
\subsubsection{公平性}
BlockDAG 是公平的因其引入的合作模型替代区块链的竞争模型.

\subsubsection*{矿池去中心}
竞争模型会导致收益波动的挖矿风险, 进而导致矿池的中心化. Qitmeer 共识协议基于合作模型的BlockDAG框架, 独立可以和矿池挖矿一样处于低风险水平, 所以矿池也会更去中心化.

\subsubsection*{抗ASIC的挖矿算法}
布谷鸟环是一个基于图理论的工作量证明算法, 因其抗ASIC的特性而流行. Qitmeer 采用这个算法以保证没有哪个矿工可以有过高的挖矿效率.
\subsubsection{安全性}
安全性是Qitmeer网络最重要的考虑因素. Qitmeer已经达到了完全的去中心化以及50\%的算力容错性. 因此, Qitmeer并没有牺牲安全性来获得其他指标的性能.
\subsubsection*{完全去中心化}
Qitmeer网络的所有节点都是对等节点并有资格参与共识. 

\subsubsection*{50\% 容错性}
恶意节点必须拥有50\%的算力才能控制整个网络. Qitmeer 共识的容错性与吞吐量无关, 无论吞吐量多高依然保持相同的容错性, 而比特币的容错性跟吞吐量是负相关的.

\subsubsection{可伸缩性}
Qitmeer 在各种可伸缩性的方面都有理想的表现, 使得它能长时间稳定运行.

\subsubsection*{快速确认}
The Qitmeer adopts the SPECTRE as consensus algorithm which is a speedy confirmation BlockDAG protocol. 
Qitmeer 集成SPECTRE, 一个高速确认的BlockDAG协议, 来保证交易的快速安全确认.
\subsubsection*{高吞吐量}
GhostDAG 是一个支持高吞吐量的BlockDAG协议, 能充分发掘潜在的伸缩性, 只受网络物理参数的限制, 例如网络带宽或传播时间.

\subsubsection*{低成本}
Technically, the cost is not scaling since the transaction fee is increasing slightly with the network growing. However, the average cost will keep relatively insignificant, reasonable for a long period.  
技术上讲, 成本不能扩张因为交易费会随着网络的增长缓慢地增长.不过平均每笔交易的成本还是相对不是太显著, 长远看还是合理的.


\section{Qitmeer 通证设计}

当前的区块链网络, 在开始项目设计的时候, 完全没有考虑到合规性以及道德关切. 相较而言, Qitmeer 将合规性根植在从底层逻辑, 并贯穿在整个技术架构, 直至生态应用. 在此过程中, Qitmeer 设计了一套有效都方案, 称之为OP_TOKEN.

\subsection{背景}
\subsubsection{问题定义}

Blockchains are ought to consider two main points to be considered as Regulation compliance in the Blockchain industry:
区块链的合规性应该要考虑两点:

\subsubsection*{内在价值}
Assets must have underlying value and cannot be created out of thin air. On existing token issuance platforms like Ethereum\cite{Ethereum}, individuals can issue arbitrary amount of token without any collateral.

资产必须存在内在价值, 不能凭空产生. 在已有的通证发布平台例如以太\cite{Ethereum}, 个人可以在不需要抵押的情况下发布任意额度的资产
 

\subsubsection*{资产认证}
The blockchain should not allow any issuance of illegitimate assets and unethical business. Existing blockchains are too unrestricted in the event of assets authentication.
区块链不应该允许非法资产的发行以及违反商业操守的行为, 已有的区块链在资产认证时没有任何限制. 

\subsubsection{相关工作}

$\texttt{OP\_TOKEN}$ 的设计灵感来源于染色币, 基于比特币的 $\texttt{OP\_RETURN}$ 和  OP\_GROUP  用于代表并管理现实生活中的资产, 其中 OP\_GROUP 是一个Andrew Stone实现的用于发行资产的参考实现, 

\subsubsection*{UTXO}

UTXO 即未花费的交易输出, UTXO用于判断一笔交易是否是合法, 在Qitmeer 网络中并不存在账号. 用户花费的是一组UTXO. 通过求和UTXO可以得到总余额.

\begin{figure}[hbt]
	\centerline{%
	   \resizebox{0.8\textwidth}{!}{\includegraphics{figures/UTXO}}%
	}
\caption{UTXO 模型}
\end{figure}

交易1 tx1 有两笔UTXO(绿色), 所以tx1有2+3=5 个币的余额.

交易2 花费了 tx1的两笔UTXO, 并支付到了三个地址, 产生了三笔新的UTXO.

注意: 现在就的UTXO (tx1的) 已经不在是UTXO了, 所以不能再被花费了.

\subsubsection*{脚本系统}

花费UTXO的机制其实就是执行一段脚本. 输出存储了一半的脚本并必须出具另外一半脚本并合并两者以验证该笔金额是否可以被花费. 前一部分称为锁定脚本, 就像一个锁住的宝箱, 后半部分叫解锁脚本, 就像该箱子唯一的钥匙.

例如, UTXO 中一段典型的 "支付到公钥哈希" (Pay-2-Public-Key-Hash(P2PKH)\cite{P2PKH}) 锁定脚本:

\begin{lstlisting}
OP_DUP OP_HASH160 <PUBLIC_KEY> OP_EQUALVERIFY OP_CHECKSIG
\end{lstlisting}

一笔新建交易的解锁脚本

<Signature><PublicKey>

将锁定脚本和解锁脚本合并

<Signature><PublicKey> OP\_DUP OP\_HASH160 <PUBLIC\_KEY> OP\_EQUALVERIFY OP\_CHECKSIG

完整的脚本包含两个步骤:
1. <PublicKey>  OP\_HASH160 <PUBLIC\_KEY> OP\_EQUALVERIFY
	验证解锁脚本中的公钥是否匹配锁定脚本中的私钥
2.  <Signature><PublicKey> OP\_CHECKSIG
	检查签名是否是合法的

\subsubsection*{染色币 和 Tether}

染色币\cite{ColoredCoins} 是一套在区块链上表示资产的方法, 它可以利用区块链防篡改的能力. 它使用${OP\_RETURN}$中断脚本的执行, 因此, 它可以在$\texttt{OP\_RETURN}$ 后面加协议内容而并不需要违反脚本的验证.

锁定脚本:
\begin{lstlisting}
OP_RETURN <DATA>
\end{lstlisting}

此外, 稳定币 Tether\cite{Tether} (USDT) 也使用了基于 OP\_RETURN 的OMNI Layer 协议来定义比特币上的资产.

典型的USDT交易以及协议设计的详细内容

\lstset{basicstyle=\tiny,style=myListStyle}
\begin{lstlisting}
OP_RETURN 6f6d6e69000000000000001f00000015c9054900
\end{lstlisting}


\begin{figure}[hbt]
	\centerline{%
	   \resizebox{0.8\textwidth}{!}{\includegraphics{figures/USDT}}%
	}
\caption{USDT}
\end{figure}


%[ref][https://www.blockchain.com/btc/tx/efc50d9e1f23e687e304cfca4ef2c5412b67d5737888ff80a0cbb6853cd865c]


\subsubsection*{OP\_GROUP}
OP\_RETURN 的设计更适合在成熟的区块链上应用, 因为它不会改变底层区块链协议, 从而不会有分叉的风险. 不过缺点在于矿工是无法验证协议, 所以可能存在一定的安全风险.

OP\_GROUP\cite{OP_GROUP}  is an improvement proposal of assets issuance on Bitcoin Cash (BCH)\cite{BCH} from Bitcoin Unlimited (BU). Thus, OP\_GROUP  supports transfer, destroy and insurance of Token. Since OP\_GROUP is an extension to the BCH script system,  it is part of the BCH protocol. Thus miners can do the verification, which is more reliable.

OP\_GROUP\cite{OP_GROUP} 是Bitcoin Unlimited (BU) 提出的针对比特现金\cite{BCH}的提案. 因此, OP\_GROUP 支持转账, 销毁以及发行通证. 因为OP\_GROUP是对BCH 脚本系统的扩展, 它是属于协议的一部分	 


基本的“染色”支付到公钥散列脚本应该是:

\lstset{basicstyle=\tiny,style=myListStyle}
\begin{lstlisting}[numbers=none]
OP_DATA(group address)
OP_GROUP
OP_DROP
OP_DUP
OP_HASH160
OP_DATA(pubkeyhash)
OP_EQUALVERIFY
OP_CHECKSIG
\end{lstlisting}

主要的区别很简单，只是添加一个组地址来区分不同的组，而其他操作，例如创建和销毁资产，是类似的。

% [ref]https://medium.com/@g.andrew.stone/bitcoin-scripting-applications-representative-tokens-ece42de81285

\subsection{OP\_TOKEN 设计}

\subsubsection{概述}

There is a unique token named LICENSE in OP\_TOKEN. The relevant regulatory bodies, shariah-governance entities, industry practitioners with public credibility within the ecosystem are invited to receive the licenses to oversight the compliances issues that might occur along the course of mainstream adoption of the protocol. Any entity planning to issue a token needs to be warranted with a license. Peers can transfer licenses as they are also tokens in nature. However, the originator must be extra careful in event of transferring in order to avoid non-compliance risk due to the records is public and immutable.  

在OP\_TOKEN中有一个名为牌照(LICENSE)的惟一通证。相关监管实体、在生态系统中具有公信力的行业从业人员将被邀请领取牌照，以监督在主流采用协议过程中可能出现的遵从性问题。任何计划发布令牌的实体都需要获得许可。对等点可以传输许可证，因为它们本身也是令牌。然而，发端人在转移时必须格外小心，以避免由于记录是公开和不可变的而造成的不遵从风险。

在OP\_TOKEN中有一个名为牌照或者许可证(LICENSE)的惟一通证。在生态系统中具有公共信誉的相关监管实体和行业从业人员被邀请领取许可证，以管理可能发生的合规性问题。任何计划发布通证的实体都需要获得许可。对等节点之间可以传输许可证，因为它们本身也是通证。由于记录是公开的、不可变的，为了避免向错误的人转移的不合规风险，发起者在转移时必须格外小心。
 

\subsubsection{许可证生成}

Licenses are all generated in the genesis block and distributed to C preserved committee members. One smallest unit (QIT) can represent a license, one block has M coins, one coin= N QIT, so we have M*N license in total, which is sufficient for asset issuance.

许可证都是在创世块中生成的，并分发给C名保护委员会成员。
一个最小的单位(QIT)可以代表一个许可证，一个块有M个本币，1个本币= N个QIT，所以我们总共有M*N个许可证，这就足够发行资产了。


\begin{lstlisting}[language=yaml, numbers=none,basicstyle=\footnotesize]
# C = 100, M = 10, N = 10^8 (M*N = 10 billion),
# all examples are based on this setting
# Ex1: Distribute licenses to the committee,
# M*N/C = 100 million for each member.
---
INPUTS:
	INPUT:
		PREVIOUS_OUTPUT: # (创世 COINBASE )
			S: "DUP HASH160 [GEN] EQUALVERIFY CHECKSIG"
			V: 10000000000
		S: "[SIG] [GEN_PK]"
OUTPUTS:
	OUTPUT:
		S: "[LIC] TOKEN DROP DUP HASH160 [COMM1] EQUALVERIFY CHECKSIG"
		V: 100000000
	# ... ... (COMMITTEE MEMBER 2~99)
	OUTPUT:
		S: "[LIC] TOKEN DROP DUP HASH160 [COMM100] EQUALVERIFY CHECKSIG"
		V:100000000
	OUTPUT:
		S: "RETURN [DATA]"
		V: 0
\end{lstlisting}



\subsubsection{颁发许可证}

The relevant entities must be warranted a license to issue assets. The entity can request a license from any committee member (C.M.). Once the license is granted and approved. These entities will receive a particular token transfer from the C.M. and the Token is the licensed.

相关实体必须获得授权才能发行资产。
实体可以向任何委员会成员(C.M.)申请许可证。
一旦许可被授予和批准。
这些实体将从委员会成员接收一个特定的，该令牌是经过许可的。

\lstset{basicstyle=\tiny,style=myListStyle}
\begin{lstlisting}[language=yaml, numbers=none,basicstyle=\footnotesize]
# 例2:  委员会颁发证书给发行方 (ISS),
# 注意许可证的余额会返还到委员会.
---
INPUTS:
	- INPUT:
			PREVIOUS_OUTPUT:
				S: "[LIC] TOKEN DROP DUP HASH160 [COMM] EQUALVERIFY CHECKSIG"
				V: 100000000
			S: "[SIG] [COMM_PK]"
OUTPUTS:
	- OUTPUT:
			S: "[LIC] TOKEN DROP DUP HASH160 [ISS] EQUALVERIFY CHECKSIG"
			V: 1
	- OUTPUT: # License change
			S: "[LIC] TOKEN DROP DUP HASH160 [COMM] EQUALVERIFY CHECKSIG"
			V: 99999999
	- OUTPUT:
			S: "RETURN [DATA]"
			V: 0
\end{lstlisting}

\subsubsection{资产发行}
一旦获得授权，实体就可以发行资产;但是，他们不能任意设置通证数量。相反，发行一定数量的资产需要转换相同数量的QIT。Qitmeer网络将这个过程称为“铸币”。就像现实中的情况一样，铸造一枚金币需要同样重量的金币，代币需要同样数量的金币。

发行制度的首要优点是保证了代币的基本内在价值;因此，它将大大缓解价格波动。另一个好处是，代币和本币不再是价值孤岛，它们在同一个生态系统中运行，将提高流动性，使整个网络稳定

\lstset{basicstyle=\tiny,style=myListStyle}
\begin{lstlisting}[language=yaml, numbers=none,basicstyle=\footnotesize]
# 例3: 转换 100000000 QIT, 即 1 MEER,
# 到 100000000 单位的新通证,
# 注意:许可证将返回给发行方以备将来发行
INPUTS:
	- INPUT:
			PREVIOUS_OUTPUT: #(1 LICENSE)
				S: "[LIC] TOKEN DROP DUP HASH160 [ISS] EQUALVERIFY CHECKSIG"
				V: 1
			S: "[SIG] [LIC_PK]"
	- INPUT:
			PREVIOUS_OUTPUT: #(1 Qitmeer Coin)
				S "DUP HASH160 [COIN] EQUALVERIFY CHECKSIG"
				V: 100000000
			S: "[SIG] [COIN_PK]"
OUTPUTS:
	- OUTPUT: # License returns to the issuer
			S: "[LIC] TOKEN DROP DUP HASH160 [ISS] EQUALVERIFY CHECKSIG"
			V: 1
	- OUTPUT:
			S: "[TOK] TOKEN DROP DUP HASH160 [PK] EQUALVERIFY CHECKSIG"
			V: 100000000
	- OUTPUT:
			S: "RETURN [DATA]"
			V: 0
\end{lstlisting}

\subsubsection{资产转移}

实体之间可以相互转移资产。
此外，实体可以在一个交易中转移多个资产。
交易需要确保每个资产的输入和等于每个资产的输出和

\lstset{basicstyle=\tiny,style=myListStyle}
\begin{lstlisting}[language=yaml, numbers=none,basicstyle=\footnotesize]
# 例4: Alice 用 Bob 的20美元代币兑换她的100元人民币代币。
INPUTS:
	- INPUT:
			PREVIOUS_OUTPUT:
				S: "[RMB] TOKEN DROP DUP HASH160 [A_PKH] EQUALVERIFY CHECKSIG"
				V: 100
			S: "[A_SIG] 0X83 [A_PK]"
	- INPUT:
			PREVIOUS_OUTPUT:
				S: "[USD] TOKEN DROP DUP HASH160 [B_PKH] EQUALVERIFY CHECKSIG"
				V: 20
			S: "[B_SIG] 0X83 [B_PK]"
OUTPUTS:
	- OUTPUT:
			S: "[USD] TOKEN DROP DUP HASH160 [A_PKH] CHECKSIG"
			V: 20
	- OUTPUT:
			S: "[RMB] TOKEN DROP DUP HASH160 [B_PKH] CHECKIG"
			V: 100
\end{lstlisting}


\subsubsection{融币}

Melt is the reversed process of mint, i.e., conversion from tokens to native currency. The total amount of qit is constant, either in the form of Native QIT or Token QIT. However, it is allowed to transform a token and convert native currency. Issuers can melt their coins to reduce liquidity in order to keep the price stable, which is practical to implement stable coins. Melt guarantees the tokens fundamental value, just like the minimum value of a gold coin is the same weight of gold.   

熔币是铸币的相反过程，即，从代币到本币的转换。无论是以本机qit还是令牌qit的形式，qit的总量都是常量。但是，它可以转换令牌和转换本地货币。发行方可以通过融币来降低流动性，以保持价格稳定，这对于稳定货币的实施是很现实的。令牌熔炼保证了令牌的基本价值，就像一枚金币的最小价值等于黄金的重量一样。

\lstset{basicstyle=\tiny,style=myListStyle}
\begin{lstlisting}[language=yaml, numbers=none,basicstyle=\footnotesize]
# 例5: 熔化 100 QIT 代币  到 100 QIT 本币 
INPUTS:
	- INPUT:
			PREVIOUS_OUTPUT:
				S: "[TOK] TOKEN DROP DUP HASH160 [ISS] EQUALVERIFY CHECKSIG"
				V: 100
			S: "[SIG] [ISS_PK]"
OUTPUTS:
	- OUTPUT:
			S: "DUP HASH160 [COIN] EQUALVERIFY CHECKSIG"
			V: 100
	- OUTPUT:
			S: "RETURN [DATA]"
		V: 0
\end{lstlisting}


\section{Consensus Protocol}

BlockDAG is a high throughput framework ,highlighted in fully decentralized and high security. Futhermore, it is a natural extension to classical bitcoin paradigm, meaning it would inherit most  long time verified qualities of bitcoin and is expected stronger stability.

Qitmeer introduces GHOSTDAG as fundamental protocol to achieve high throughput linearly ordering service with fast confirmation guaranteed by SPECTRE protocol.

\subsection{From BlockChain To BlockDAG}
Bitcoin does not scale due to protocol restrain. By Nakamoto Consensus, i.e., longest-chain rule, 1 MB block size and 10 minutes block rate confine bitcoin to reach only 7 TPS theoretical throughput regardless of the bandwidth and propagation delay.

The most intuitive way to increase scalability is to shorten block time or enlarge block size. The reason why Satoshi did not adopt is because that will bring forks, as well as distracting the hash power from the main chain, thus causing security vulnerability.

GHOST protocol introduces heaviest-tree consensus to keep forks without sacrificing security. Note that here BlockChain has transformed into a BlockTree. Since the largest subtree has concentrated the majority hash power, the security is as high as bitcoin. The main chain is the path, i.e. a blockchain from the genesis to leaf, with the highest number of descendants, other blocks are off-chain blocks. Only main chain blocks contribute throughput, off-chain blocks help strengthen the security. 

BlockTree has dramatically increased throughput because of the higher Block Rate or Size. However, there is still a waste of the transactions of off-chain blocks, which should contribute to the throughput as well. Inclusive\cite{Inclusive} protocol proposes a new data structure of ledger, where every block confirms every unconfirmed block. This improvement upgrades a BlockTree to a BlockDAG.

Through the development history from BlockChain to BlockDAG, it may indicate  that BlockChain is a particular case of BlockDAG in the event of low throughput, which means both are the same in essence. As a result,  it is the scaling approach whose paradigm is the closest to the bitcoin network. BlockDAG is robust since it inherits all the long-time-proved stable features of bitcoin,  as well as it could scale infinitely in terms of protocol, unless it is limited physically, such as, bandwidth. A robust public chain is the optimal basis for incorporating further scaling solutions, such as sharding and state-channels, thus BlockDAG is the preferred scaling solution of Qitmeer.


\begin{figure}[hbt]
	\centerline{%
	   \resizebox{0.8\textwidth}{!}{\includegraphics{figures/DAG.png}}%
	}
\caption{DAG}
\end{figure}

\subsection{GHOSTDAG}

GHOSTDAG, formerly Phantom, is the first BlockDAG protocol with block total ordering support. What is more, comparing to SPECTRE, it guarantees strong liveness to make the consensus protocol more robust. That is to say, both honest blocks and malicious blocks can be confirmed within a definite time, though it may take longer time to confirm malicious blocks.


\subsubsection{Intuition}

Here is the idea behind GHOSTDAG. Suppose that the maximal limits of network propagation delay and block creation
rate are constant. It is intuitive that if nodes behave honestly, it forms a subgraph where each block has at most a constant number of forks. We denote
this constant number as $k$. $k$ can be calculated from propagation time and
block creation rate. The subgraph is denoted as a $k$-cluster. The biggest
$k$-cluster is called a blue set. Those blocks outside the blue set are called
red set.

If we can traverse from block $x$ to block $y$ by following the parent
references within each block, then we say that there's a partial order between
$x$ and $y$, and $y$ is prior to $x$. For example in the following figure, we
can traverse from block J to A through B, so there's a partial order between A
and J, and A is prior to J. Note not all blocks have partial orders with other
blocks. For example, there are no partial orders between B, C and D.  The block set where no partial order exists is an anticone. The size of any anticone in
a $k$-cluster is at most $k$.

\begin{figure}[ht]
	\centerline{%
	   \resizebox{0.8\textwidth}{!}{\includegraphics{figures/GHOSTDAG}}%
	}
\caption{GHOSTDAG}
\end{figure}


\subsubsection{Ordering}

GHOSTDAG orders the DAG ledger in a way that favours blue blocks and penalizes
red ones. So, if two blocks X and Y have no partial order from the graph, the one in blue set is prior to the one in the red set.

The coloring algorithm is based on a block's past set, also known as ancestors, since the past set gets fixed after a block generated, the blue set will get fixed as well. Therefore, each block could choose the parent with maximal blue set as its main parent. Then, repeat the process of finding main parent from the tip blocks extending to the genesis block, finally we could figure out a unique block chain that is under agreement by the majority of the network, we name this block chain as main chain. Once main chain is identified, all the blocks could form a linearly order in reference to it. 


\begin{figure}[ht]
	\centerline{%
	   \resizebox{0.8\textwidth}{!}{\includegraphics{figures/Ordering}}%
	}
\caption{GhostDAG Ordering}
\end{figure}

For example in figure 5, this is a 3-cluster DAG. 

\begin{enumerate}
	\item Add genesis block G in blue set
	\item Add B,C,D,E to blue set, since none of them has an anticone greater than 3
	\item Since the blue set of H is greater than that of F and I, so add H in blue set. Add I to blue set because its anticone size is only 2; Add mark B and F in red set for anticone size greater than 3
	\item J,K,L arrived. Both past set size and blue set size of J and K are the same, so currently there are two possible main chain, G-C-H-J and G-C-H-K 
	\item M arrived, since M's blue set is greater than that of J and L, M is added to blue set, so there is only one main chain left, G-C-H-K-M. Add J to blue set due to small anticone size then add F, L to red set due to big anticone size, now red set and blue set as well as main chain are identified
	\item the order is G-C-D-E-H-I-B-K-F-j-M-L
\end{enumerate}

\subsection{SPECTRE}
SPECTRE\cite{SPECTRE} is a BlockDAG based protocol that achieves fast confirmation and high throughput with 50\% attack resilience. SPECTRE guarantees safety, which means the transaction is unlikely to be reversed once it is accepted. However, the SPECTRE guarantees fast confirmations for honest users rather than all users which is weak liveness.

There is a trade-off between liveness and fast confirmation, whereby SPECTRE prioritizes the latter due to weak liveness only affects malicious users, that enables SPECTRE to be a suitable protocol for payment model. In the event malicious users launch double spending attack, their transactions are likely to be delayed indefinitely.

SPECTRE is a stateless transaction model, whereby there is no need to gain a total ordering over all the blocks. Only when two blocks conflicting that a pairwise ordering is needed. SPECTRE employs a voting algorithm to decide which block wins when there is a conflict between two blocks. Suppose block x has a conflicting transaction with another transaction in block y, and also suppose that block z is voting on them with the following rules:

SPECTRE employs a voting algorithm to decide which block wins when two blocks
conflict. Suppose block $x$ has a conflicting transaction with another
transaction in block $y$, and also suppose that block $z$ is voting on them with
the following rules:

\begin{enumerate}
	\item If $z$ is in $x$'s future but not in $y$'s future, $z$ votes for
		$x$ in favor of $y$, denoted as $x \prec y$, and vice versa.
	\item If both $x$ and $y$ are in the past of $z$, then $z$ follows the majority votes in its past.
	\item If neither $x$ nor $y$ is in the past of $z$, then $z$ follows the majority votes in its future.
	\item Both $x$ and $y$ vote for themselves unless one is in the past of
		the other.
\end{enumerate}


Here's an example of how a new block (number 12 in the figure below) votes:

\begin{figure}[ht]
	\centerline{%
	   \resizebox{0.8\textwidth}{!}{\includegraphics{figures/SPECTRE}}%
	}
\caption{An example of the voting procedure in the DAG for blocks $x$ and $y$ in SPECTRE}
\end{figure}

According to rule 4, block $x$ votes for $x \prec y$, block $y$ votes for $y
\prec x$.

According to rule 1, blocks 6, 7 and 8 vote for $x \prec y$, blocks 9, 10 and 11
vote for $y \prec x$.

According to rule 2, block 12 votes according to its past. Since not all blocks
of its past have voted, we change global view to block 12's local view, which
means block 10 and 11 are excluded.

According to rule 3, block 5 votes for $x \prec y$, since the majority of its
future vote in favor of $x$ over $y$ (blocks 7, 8 versus block 9). Note that the
current view is block 12's local view and block 11 is excluded, so we cannot
take its vote.

Also according to rule 3, blocks 1\textasciitilde4 vote for $x \prec y$.

Now all the blocks in block 12's past have voted. Block $x$ gets 10 votes. Block
$y$ gets 2 votes. Block 12 follows the majority and votes for $x \prec y$ thus.


\subsubsection*{Confirmation Time}

When a node $v$ receives a block $x$, it loops to calculate the  risk of
the block. It accepts the block when the risk is smaller than a given threshold
$\epsilon$. The confirmation time of block $x$ in node $v$ is the time
since $x$ is received by $v$ until $x$ is accepted by $v$.

The following algorithm below calculates the  risk of block $x$ in
$G_t^v$, where $G_t^v$ is the block DAG that $v$ observes at time $t$.

\begin{codebox}
\Procname{\proc{Risk}$(G_t^v, x)$}
\li \If $time\_now < publication(x)$
\li   \Then
        \Return 1
      \End
\li $T \gets time\_now - received^v(x)$
\li $G_x \gets G_{received^v(x) + 2 \cdot d} \cup future(x, G_t^v)$
\li $g \gets \min_{x' \in \overline{ainticone}(x,G_x)} |future(x',G_x)|$
\li \Return $risk\_hidden(T,g)$
\end{codebox}

The formula $risk\_hidden(T,g)$ is defined as:

$$
risk\_hidden(T,g) := \sum_{l=0}^{\infty} \pi(l) \sum_{m=0}^{\infty} Poiss((T + 2
\cdot d) \cdot \alpha \cdot \lambda, m) \cdot \left(\frac{\alpha}{1 -
\alpha}\right)^{(g - l - m)^+},
$$

where

\begin{itemize}
	\item $d$ is the upper bound on the recent delay diameter in the network,
	\item $\alpha$ is the attacker’s relative computational power,
	\item $\lambda$ is the block creation rate,
	\item $Poiss(a, b)$ is defined as $e^{-a} \cdot \frac{a^b}{b!}$,
	\item $x^+$ is defined as $\max\{0, x\}$,
	\item and $\pi$ is the stationary distribution which we will explain below.
\end{itemize}

$risk\_hidden(T,g)$ upper bounds the probability that block $x$ is preceded by
some attacker’s block $y$ in pairwise order, where $y$ is published later than
$x$.

$\pi$ is actually a vector. Informally, it is the statistical distribution of
how much more blocks attacker nodes have created than honest nodes have created
since block $x$ is published, which is called gap in the SPECTRE paper. $\pi(l)$
is the probability that the value of gap is $l$.

The value of gap changes as time goes on, forming a random walk which induces an
ergodic Markov chain. Theoretically, it could be any integer ranging from
negative infinity to positive infinity. In the worst case, it is always
non-negative. Only when the gap is non-negative is there a risk for block $x$ to
be received less or equal votes than some attacker’s block $y$ which is
published later than $x$, so that $y$ precedes $x$ in pairwise order. This is
why in the formula of $risk\_hidden$ the index $l$, i.e. the value of gap,
starts out equal to 0 instead of negative infinity.

Since the random walk of $l$ induces an ergodic Markov chain, $l$ has a unique
stationary distribution, which is $\pi$. In order to calculate $\pi$, we need to
calculate the transition probability matrix of the random walk.

Suppose that the value of $l$ ranges from 0 to $N$, where $N$ is infinity in the
above definition. We define the transition probability matrix as an $N$ by $N$
matrix $T$. We also denote by $\delta := \alpha \cdot \lambda \cdot d$. For all
$1 \leq l < N - 1$, $T_{l-1,l} = 1 - \alpha, T_{l+1,l} = \alpha$, and for $l = N
- 1$: $T_{l-1,l} = 1 - \alpha, T_{l,l} = \alpha$. The first column of the matrix
is defined by: $T_{0,0} := (1 - \alpha) \cdot e^{-\delta}, T_{1,0} = e^{-\delta}
\cdot \alpha + e^{-\delta} \cdot \delta$, for $1 < l < N - 1$: $T_{l,0} =
e^{-\delta} \cdot \frac{\delta^l}{l!}$, and $T_{N-1,0} = 1 - e^{-\delta} \cdot
\left[\frac{\delta^0}{0!} + \frac{\delta^1}{1!} + \cdots +
\frac{\delta^{N-2}}{(N-2)!}\right]$.  $\pi$ is the eigenvector of $T$
corresponding to the eigenvalue 1, where $\pi(l) \geq 0$ and the sum of $\pi$ is
1.

In practice, $\pi(l)$ is very close to zero when $l$ is very large, so we can
just pick some $N \gg 1$ instead of infinity. Therefore, the formula of
$risk\_hidden$ becomes

$$
risk\_hidden(T,g) = \sum_{l=0}^{N} \pi(l) \sum_{m=0}^{\infty} Poiss((T + 2 \cdot
d) \cdot \alpha \cdot \lambda, m) \cdot \left(\frac{\alpha}{1-\alpha}\right)^{(g
- l - m)^+}.
$$

It is recommended to calculate $\pi$ with some well-tested Markov chain library such
as the markovchain package in R.

The sum of series with index $m$ seems to be a sum of infinite series. However,
for $m > g - l$ we have $(g - l - m)^+ = 0$ and
$\left(\frac{\alpha}{1-\alpha}\right)^{(g - l - m)^+} = 1$.

Therefore, the formula of $risk\_hidden$ can be further converted as below,
where $Poiss_{cdf}$ is the cumulative distribution function (CDF) of Poisson
distribution.

\begin{align*}
risk\_hidden(T,g)
=& \sum_{l=0}^{N}\pi(l)\sum_{m=0}^{\infty}Poiss((T+2 \cdot d) \cdot \alpha \cdot \lambda, m) \cdot (\frac{\alpha}{1-\alpha})^{(g-l-m)^+} \\
=& \sum_{l=0}^{N}\pi(l) (\sum_{m=0}^{g-l}Poiss((T+2 \cdot d) \cdot \alpha
	\cdot \lambda, m) \cdot (\frac{\alpha}{1-\alpha})^{(g-l-m)} + \\
& \sum_{m=(g-l+1)^+}^{\infty}Poiss((T+2 \cdot d) \cdot \alpha \cdot \lambda, m)) \\
=& \sum_{l=0}^{N}\pi(l) ( \sum_{m=0}^{g-l}Poiss((T+2 \cdot d) \cdot
	\alpha \cdot \lambda, m) \cdot (\frac{\alpha}{1-\alpha})^{(g-l-m)} + \\
& (1 - Poiss_{cdf} ((T+2 \cdot d) \cdot \alpha \cdot \lambda, (g-l)^+))).
\end{align*}

With the converted formula we are able to calculate $risk\_hidden$ in numerical way. Figure 5 simulates the confirmation time on different block rates, it show that SPECTRE could achieve 5 seconds confirmation time on block rates higher than 10 blocks per second and 10\% faulty percentage, which is considerably promising.

\begin{figure}[ht]
	\centerline{%
	   \resizebox{0.8\textwidth}{!}{\includegraphics{figures/confirmation.jpeg}}%
	}
\caption{Confirmation Time}
\end{figure}


\subsection{Mining Algorithm}
BlockDAG’s collaboration model provides much more fairness than the competition model of BlockChain on the protocol perspective. Every node gets rewards according to its contribution, regardless of how much hash power it possess. Qitmeer favors fairness over the scalability owing to the former is more in line with true spirit of blockchain. The intention of Nakamoto Consensus is fair - every node votes with electricity; however, only a small bunch of the mining pools have the odds to participate in consensus. solo miners suffer huge opportunity cost since they have to wait for an uncertain time, quite long in most cases, to mine a block to cover their cost; thus finally it will have to turn to the mining pools. BlockDAG incorporates every miner’s block, the miners have a strong expectation of their return and then discourage to join a mining pool.


In addition, the mining algorithm is  another factor of fairness. Mining fairness refers to a certain amount of mining cost, such as electricity in POW, should derive the relatively equivalent amount of hash power. Practically, the ASIC mining rigs have much more mining efficiency than their prices.

\subsubsection{Cuckoo-Cycle-PoW}
Proof-of-Work(PoW) is used to confirm transactions and produces new blocks, and acts as the driving force in PoW based cryptocurrencies. PoW must not enable a participant to have a significant advantage over another participant. That is why Satoshi said: "Proof-of-work is essentially one-CPU-one-vote."

However, most widely used proof-of-work algorithms, such as SHA-256, Blake2b, Scrypt, are more efficient on ASIC devices when compared to CPUs and GPUs. This can lead to ASIC owners posses a much larger voting power than CPU and GPU owners, which violates the “one-CPU-one-vote” principle.

Cuckoo-Cycle-PoW, a graph-theoretic proof-of-work algorithm/ASIC-Resistant, is designed to find certain subgraphs in large pseudo-random graphs. This algorithm is ASIC resistant which  utilizes almost all parts of consumer-grade hardware in the  (GPUs, Graphic Processing Unit),

The Cuckoo Cycle POW is designed to find certain subgraphs in large pseudo-random graphs. In particular, Search for cycles of specified length L in a bipartite graph with M edges of N nodes. If a cycle is found and the hash difficulty is less than the target difficulty, the cuckoo cycle PoW is completed.




\textbf{Edge(Node) generation}

For the sake of simplicity, we define 32 edges for the bipartite graph. We call the SIPHASH function twice to create two edge endpoints(U and V), with the first input value being 2 * nonce, and the second 2 * nonce+1. The key for this function is based on a hash of a block header.

\begin{equation}
{U = SIPHASH(headerHash, 2*nonce) \mod 31}
\end{equation}
\begin{equation}
{V = SIPHASH(headerHash, 2*nonce+1) \mod 31}
\end{equation}

where,
\begin{equation}
0\leq\ {\bf nonce} \leq 31
\end{equation}it is any number between 0 and 31. Each nonce corresponds to two edge endpoints(U and V).

To throw 32 edges into a graph, randomly:

\begin{figure}[ht]
	\centerline{%
		 \resizebox{0.8\textwidth}{!}{\includegraphics{figures/edge_generation}}%
	}
	\caption{Building Nodes.}
\end{figure}


\textbf{Edge Trimming}

There is a special edge in bipartite graph, which is leaf edge, and could never be part of a cycle. Leaf edge has a feature that the nodes it connects must have at least one node with the degree of the nodes being one. By eliminating leaf edge in the bipartite graph, it could greatly reduce the complexity of the graph, thus speeding up finding cycle from the bipartite graph.

\begin{figure}[ht]
	\centerline{%
		 \resizebox{0.8\textwidth}{!}{\includegraphics{figures/edge_trimming}}%
	}
	\caption{Trimming of edges which cannot be part of a cycle.}
\end{figure}

\begin{itemize}
	\item Step 1: node 0, node 3 and node 10 are one degree nodes, eliminating the edge (0,13), (6, 3) and the edge (10,9).
	\item Step 2: node 9 and node 13 are one degree nodes, eliminating the edge (8,9) and the edge (2,13).
	\item Step 3: node 8 is one degree nodes, eliminating the edge (8,11).
\end{itemize}


\textbf{Cycle detection}

After edge trimming, if a cycle of length L is found, we think we have found a solution to this problem.
we store the cycle edges in a set and put the nonce of the generated cycle in a set and
return as the result of cycle detection.


\textbf{Difficulty control}

The difficulty of finding a cycle in the graph is proportional to M/N. Here M stands for edges of the graph.
N stands for nodes of the graph. However, the difficulty of finding a cycle in the graph change is not smooth.
For crypto currencies, difficulty control must be scale in precisely controlled manner. The usual practice is
that the ratio of M/N remain fixed, such as M/N = 1/2.

Thus in the actual use, it also adds a hash difficulty control similar to Bitcoin. The digest of the cycle nonces is obtained by a hash function,
and then compared with the target difficulty.

\subsubsection{Difficulty Adjustment}
To keep block creation, a.k.a block rate, stable, Qitmeer adjust mining difficulty periodically. 
The adjustment rule is deviated from BlockChain due to forks of BlockDAG

\subsubsection*{Blue Set Based}
Rather than based on all the blocks, Qitmeer adjustment different merely on Blue blocks. 

\subsubsection*{Dynamic adjustment interval}
It is complicated to adjust the difficulty every fixed number of blue blocks, because different block has different blue set, leading difficult to make a agreement on which block to be the adjustment point.

Qitmeer exploits main chain to overcome this problem. The rule is:

\begin{enumerate}
	\item  Wait until 144 blocks newer than last adjustment point in main chain.
    \item  Calculate the actual time, which is the time span from last adjustment point to now.
    \item  Calculate new blue blocks created.
    \item  Calculate the expected time of those blue blocks by multiply the number with block time.
    \item  Adjust the difficulty by comparing expected time and actual time.
\end{enumerate}



\section{Incentive system}
The economic drive for the miners to work for a blockchain network is a reasonable incentive system. Qitmeer distributes rewards in a fully decentralized way - mining. Qitmeer concerns fairness among all the nodes, regardless how much power one owns. For miners with strong hash power, they may strive for the block reward, which is abundant, though more competition intensive ; for those with less power, they still got the chance to share transaction fee, first come first serve.

\subsection{Block Reward}
Miners create a block, including all the unconfirmed transactions, and add a transaction funding to themselves with a commonly admitted amount, then find the cryptic solution and broadcast it to the network. That's simply how mining works, and  this self transfer is called coinbase reward or block reward. 

Block reward is considerable and incentives miners to compete intensively to obtain.  BlockDAG paradigm is a collaboration model, therefore the threshold could be lower and the distribution  fairer, however, block reward is essentially a scare resource that requires miners with considerable hash power to take part in this game.

\subsection*{Blue Set Only}
As clarified in Consensus Protocol section, GhostDAG protocol colors the honest blocks with blue and the dishonest with red. Qitmeer gives block rewards only to those blocks colored as blue.
Qitmeer identifies merely block rewards of blue blocks as valid, the reasons as below.

\subsubsection*{Encourage miners working actively}
The network is rely on miners working hard to consolidate security. Competition in BlockDAG paradigm is not be as intensive as that in BlockChain, therefore we need to encourage miners working positively to better secure the network. Since working passively has higher probability to be identified as red block, miners will work hard to avoid such situation.

\subsubsection*{Resilient to potential attack}
The instinct of BlockDAG to incorporate forks makes it more inclusive than BlockChain. However, it would reduce the cost to perform an attack because even the failing blocks will be included in the ledger. Since the failing blocks are probably identified as red blocks and paid nothing, it increases the investment of attack dramatically and attacker would not carry on attacks abruptly.

\subsection{Transaction Fee}
Blue Set policy would consolidate the security considerably, nonetheless it brings discrimination to those miners with less hash power or worse network traffic condition. Perhaps they are honest miners as well but still are identified as "dishonest" due to consensus protocol's limitation. Therefore, we could utilize transaction fee to compensate those less powerful honest miners. 

\subsubsection{Every block gets paid transaction fee}
The block reward aims at security while the transaction fee is targeting more on underlying service - value transfer. So the reward policy for transaction fee cares more about fairness, if you devoted to the network, the network would pay you accordingly regardless how much hash power you have.

Other than block reward is orientated merely from  blue blocks, transaction fee is transferred on every blocks, even marked as red. So, miners get paid as long as they work hard. E.g., due to locality, the miners prioritizes to incorporate transactions geographically around them. So, even if their blocks broadcast slower due to poor network traffic and eventually marked as red, they still could receive those transaction fee.

\subsubsection{Weighted transaction fee}
Due to asynchronous block submission, BlockDAG protocols inevitably incorporate repeating transactions, called transaction collisions.
Miners tend to pack the transaction with higher fees to maximize their profit. This will result in high repetition rates of blocks. Repeated transactions will not contribute to the throughput, what is more, low fee transactions would wait indefinite time to get confirmed. In a fully decentralized network, nodes cannot coordinate each other to avoid collision, leaving the only option to devise a sophisticated incentive mechanism to penalize the selfish mining behaviors.

The intuitive way to solve this challenge is to share the transaction fee, and this method will make all the miners reach a Nash equilibrium that all the miners will choose transactions randomly from their memory pools. This approach will considerably reduce transactions collision; however, users would no longer pay higher fees to boost their transaction confirmation, so this policy would break the functionality of transaction fee.

Inspired by inclusive protocol, Qitmeer takes on a simpler Weighted Transaction Fee policy to balance the functionality and collision. The policy is really simple, higher transaction has accordingly higher probability to be included. E.g., if one transaction fee is 2 times higher than another, it is two times more likely to be picked from the mempool.

\subsubsection{First Come First Serve}
Inspired by Inclusive protocol as well, Qitmeer takes on First Come First Serve policy for transaction fee. The idea is straightforward, whoever is the first one to include the transaction wins the transaction fee.

However, the implementation of this idea is not as easy as expected and is not covered in Inclusive paper. By bitcoin's diagram, miners collect transactions fee in coinbase as well, at this phrase, its order is undetermined. Simply put, the miner has no idea which transaction will be the first included than the rest of the network, the only way is to assume all the the transactions will be the first and collect all the fee, but actually some of them would be identified invalid.

Qitmeer's solution to this problem is to balance this coinbase transaction when the miners tried to spend it. For instance, if a miner creates a block with 3 transactions with 0.1 meer fee each, finally identified 2 out of 3 are first included, the rest is not. When the miner creates a transaction to spend this block reward, he has to add an output pointing to a special address with amount 0.1 to burn the redundant fee.

\section{Protocols and Interoperability}
BlockChain is the digital infrastructure for decentralized financial system, which would evolve into a complete ecosystem in the course of reaching maturity. This session analyses the typical applications available on  Qitmeer network and the protocols for interaction with Qitmeer. 

\subsection{Mining Protocol}
\subsubsection{Proof-of-work Algorithm}

The mining protocol is resistant to the centralization of mining power, which enables miner utilize almost all parts of commodity hardware (GPUs, CPUs).
Therefore, Qitmeer uses a Proof-Of-Work algorithm called Cuckoo Cycle\cite{cuckoocycle},
a memory-hard algorithm. This algorithm is designed to find certain subgraphs in large pseudo-random graphs.
An introduction of Qitmeer proof-of-work can be found here.\cite{qitmeerpow}

\subsubsection{Mining Protocol}

\begin{figure}[ht]
	\centerline{%
		\resizebox{0.8\textwidth}{!}{\includegraphics{figures/mining_process}}%
	}
	\caption{Mining process.}
\end{figure}

Qitmeer supports getblocktemplate mining protocol. It make the miner to decide which transactions are put in the block. The miner send a request to the Qitmeer full node by getblocktemplate RPC.
\begin{lstlisting}
{
	"jsonrpc": "2.0",
	"method": "getBlockTemplate",
	"params": [
				[
					"'$capabilities'"
				]
			],
	"id": 1
}
\end{lstlisting}
getblocktemplate return a JSON Object.
\begin{lstlisting}
{
	"jsonrpc": "2.0",
	"id": 1,
	"result": {
		"bits": "207fffff",
		"stateroot": "0000000000000000000000000000000000000000000000000000000000000000",
		"curtime": 1567323822,
		"height": 6,
		"previousblockhash": "50474e0a6f88f2f1aee7a0134a7be4b6e5ab6a7c9ba440b6c11c54494ca89d32",
		"sigoplimit": 80000,
		"sizelimit": 1310720,
		"weightlimit": 4000000,
		"parents": [
		{
		"data": "329da84c49541cc1b640a49b7c6aabe5b6e47b4a13a0e7aef1f2886f0a4e4750",
		"hash": "50474e0a6f88f2f1aee7a0134a7be4b6e5ab6a7c9ba440b6c11c54494ca89d32"
		}
		],
		"transactions": [],
		"version": 4,
		"coinbaseaux": {
		"flags": "092f7169746d6565722f"
		},
		"coinbasevalue": 45000000000,
		"longpollid": "50474e0a6f88f2f1aee7a0134a7be4b6e5ab6a7c9ba440b6c11c54494ca89d32-1567323822",
		"target": "7fffff0000000000000000000000000000000000000000000000000000000000",
		"maxtime": 1567331022,
		"mintime": 1567323743,
		"mutable": [
		"time",
		"transactions/add",
		"prevblock",
		"coinbase/append"
		],
		"noncerange": "00000000ffffffff",
		"capabilities": [
		"proposal"
		]
	}
}
\end{lstlisting}

Then the miner start PoW using the data from getblocktemplate RPC. If it get the right 'answer', submiting the potential block by submitblock RPC.
\begin{lstlisting}
{
	"jsonrpc": "2.0",
	"id": 1,
	"method": "submitBlock",
	"params": [
	"data"
	]
}
\end{lstlisting}

\subsubsection{Miner Capability}

The Qitmeer-Miner supports both solo mining and pool mining.

\subsubsection*{Solo}
If the miner  decided to mine Qitmeer without joining a pool, he would launch Solo mining mode. Solo miner connects one full node, call RPC service to mine blocks. Solo miner is recommended GPU implementation to gain better efficiency.

\subsubsection*{Pool}
Qitmeer mining pools support stratum mining protocol as most PoW mining pools do.
For example:

\emph{miner.exe -o stratum+tcp://serverIp:3177 -m YourWalletAddress.YourMachineId}

\subsection{Wallet Protocol}
\subsubsection{Overview}
   The blockchain wallet itself does not store any digital currency, and is primarily a computer program for creating digital currency transactions, tracking balances, and making it easy for users to manage addresses and private keys. Wallet software is the foundation of the whole block chain ecological development, any industry service can be realized through a block chain wallet value, block chain technology itself will reconstruct the traditional Internet business model in its own way. 
\subsection*{Openness}
   An excellent blockchain public chain project should be more inclusive and open. Therefore, in addition to its own official wallet, Qitmeer has designed all interfaces and SDK for third-party wallet development at the beginning of development. Third party wallet institutions can use these interfaces to develop a variety of wallet programs that support Qitmeer Token transactions. Including: HD wallet, SPV wallet, browser wallet to meet a variety of user needs.
\subsection*{How to create a wallet}
   The following is a simple wallet creation and transaction steps:
\begin{enumerate}
	\item  Generate seeder.
    \item  Derive private key.
    \item  Derive public key.
    \item  Derive address.
    \item  Monitor for outputs.
    \item  Create unsigned Transactions.
    \item  Sign Transactions.
    \item  Broadcast Transactions.
\end{enumerate}

   To complete the above operations, we need to rely on qitmeer's Qitmeer SDK and RPC interface.
   The Qitmeer SDK is a collection of tools that integrates various encryption, decryption, and signature functions. We can use the Qitmeer SDK to develop the following functions:

   \begin{enumerate}
     \item Generate seeder.
     \item Derive private key.
     \item Derive public key.
     \item Derive address.
     \item Create unsigned Transactions.
	 \item Sign Transactions.
   \end{enumerate}

   RPC is a http-based network interface, it’s easy to interact with qitmeer network. We can use the Qitmeer SDK to develop the following functions:

   \begin{enumerate}
    \item  Get block count from block dag or block chain.
    \item Get block data with block height.
    \item  Gettransaction data with txid.
    \item  Gets all transaction data waiting for confirmation.
    \item  Monitor for outputs.
    \item  Broadcast Txes.
   \end{enumerate}


\subsection{Cross Chain}
Qitmeer is dedicated to undertake the tokenized liquidity and host applications of global ecosystem of Inclusive and Ethical finance. Consequently the design goal of Qitmeer is to build up a simple and robust UTXO-based value transfer network, which prefers interoperability solutions to integrate various blockchains and applications, such as smart contract. Eventually, they will be part of Qitmeer’s ecosystem and can interact with each other.

\subsubsection{UTXO interoperability}
Currently, Qitmeer has supported P2SH script contracts and cross-chain functions through hash-locking.

\subsubsection*{Process (BTC to MEER)}

The implementation process of hash locking across the chain is:

\begin{enumerate}
\item  Alice and Bob generate their addresses on 'MEER' and 'BTC' chains respectively;

\item Alice generates her own \textit{Secret Key} and \textit{Secret Key hash};

\item Alice locks her 'MEER' token into the hash-lock contract in the main chain of 'MEER'. The unlocking condition is that Bob holds the \textit{Secret Key} or returns it to Alice after exceeding the specified time;

\item Bob checks the contract of Alice's main chain in 'MEER' and uses \textit{Secret Key hash}   to generate the corresponding contract in 'BTC'. The unlocking condition is that Alice holds the \textit{Secret Key} or returns it to Bob after the specified time;

\item Alice uses \textit{Secret Key}  to take  'BTC' locked by Bob from the hash-lock contract;

\item After obtaining \textit{Secret Key}, Bob  takes 'MEER' locked by Alice from the hash-lock contract and completes the transaction;

\end{enumerate}

\begin{figure}[hbt]
	\centerline{%
	   \resizebox{0.8\textwidth}{!}{\includegraphics{figures/UTXOAtomicSwap.jpg}}%
	}
\caption{UTXO Atom Swap}
\end{figure}



\subsubsection{Smart Contract Interoperability}

Qitmeer completes the cross- chain transaction between the block chain assets of Qitmeer and  other account models through hash lock Smart contract.

\subsubsection*{Smart Contract Interoperability Process (ETH to MEER)}

\begin{enumerate}
\item  Alice and Bob generate their addresses on 'MEER' and 'ETH' chains respectively;

\item   Alice generates her own \textit{Secret Key} and \textit{Secret Key hash};

 \item  Alice locks her 'MEER' token into the hash-lock contract in the main chain of 'MEER'. The unlocking condition is that Bob holds the \textit{Secret Key} or returns it to Alice after exceeding the specified time;

 \item  Bob checks the contract of Alice in the main chain of 'MEER' and generates the corresponding contract on 'ETH' using \textit{Secret Key hash}. The unlocking condition is that Alice holds the \textit{Secret Key } or returns it to Bob after exceeding the specified time.

 \item  Alice uses \textit{Secret Key} to call Smart Contract to take 'ETH';

 \item  After obtaining \textit{Secret Key}, Bob takes 'MEER' locked by Alice in the hash-lock contract and completes the transaction;

\end{enumerate}


\clearpage
%\appendix
%\section{Appendix}
%\begin{appendices}
%\section{append A}

%Foo bar Foo bar Foo bar Foo bar Foo bar Foo bar Foo bar Foo bar Foo bar Foo bar

%\end{appendices}

%\bibliographystyle{plainnat}
%\bibliographystyle{unsrt,acm}
\bibliographystyle{unsrt}
\bibliography{qitmeer_whitepaper_cn}

\end{document}

